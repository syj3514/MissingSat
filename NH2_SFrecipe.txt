# From namelist
&SF_PARAMS
t_star=0.632456          !SF timescale (Gyr)
n_star=5.               !SF denstiy threshold (H/cc), Combined with n_gmc
fstar_min=0.5             !adjust star mass by this fraction
T2_star=0.1              !typical ISM polytropic temperature
g_star=1.0               !typical ISM polytropic index
sf_virial=.false.
sf_model=6               !Kimm+ 2017 SF model
eps_star=0.5             !base SF efficiency (was not settable in NH!)
write_stellar_densities=.true. !save gas density at star formation


# RAMSES YOMP
`star_formation.f90`
##################################################
! ISM density threshold from H/cc to code units
nISM = n_star = 5 (from nml)
nCOM = del_star*omega_b*rhoc*(h0/100.)**2/aexp**3*XH/mH
    * del_star=2.D2     ! Minimum overdensity to define ISM
    * omega_b=0.0455
    * rhoc = 1.8800000d-29
    * XH = X = 0.76
    * mH = 1.6600000d-24
nISM = MAX(nCOM,nISM)
d0   = nISM/scale_nH
##################################################


##################################################
d         = uold(ind_cell(i),1)
! Compute temperature in K/mu
T2        = (gamma-1.0)*uold(ind_cell(i),5)*scale_T2
! Correct from polytrope
T_poly    = T2_star*(uold(ind_cell(i),1)*scale_nH/nISM)**(g_star-1.0)
T2        = T2-T_poly
! Compute sound speed squared
cs2       = (gamma-1.0)*uold(ind_cell(i),5)

! prevent numerical crash due to negative temperature
cs2       = max(cs2,smallc**2)
! Correct from polytrope
cs2_poly  = (T2_star/scale_T2)*(uold(ind_cell(i),1)*scale_nH/nISM)**(g_star-1.0)
cs2       = cs2-cs2_poly
! We need to estimate the norm of the gradient of the velocity field in the cell (tensor of 2nd rank)
! i.e. || A ||^2 = trace( A A^T) where A = grad vec(v) is the tensor.
! So construct values of velocity field on the 6 faces of the cell using simple linear interpolation
! from neighbouring cell values and differentiate.
! Get neighbor cells if they exist, otherwise use straight injection from local cell
ncell = 1 ! we just want the neighbors of that cell
ind_cell2(1) = ind_cell(i)
call getnbor(ind_cell2,ind_nbor,ncell,ilevel)
d1           = uold(ind_nbor(1,1),1) ; d2 = uold(ind_nbor(1,2),1) ; d3 = uold(ind_nbor(1,3),1)
d4           = uold(ind_nbor(1,4),1) ; d5 = uold(ind_nbor(1,5),1) ; d6 = uold(ind_nbor(1,6),1)
##################################################


##################################################
!!!!!!!!!!!!!!!!!!
! Divergence terms
!!!!!!!!!!!!!!!!!!
ul        = (d2*uold(ind_nbor(1,2),2) + d*uold(ind_cell(i),2))/(d2+d)
ur        = (d1*uold(ind_nbor(1,1),2) + d*uold(ind_cell(i),2))/(d1+d)
sigma2_comp = sigma2_comp + (ur-ul)**2
ul        = (d4*uold(ind_nbor(1,4),3) + d*uold(ind_cell(i),3))/(d4+d)
ur        = (d3*uold(ind_nbor(1,3),3) + d*uold(ind_cell(i),3))/(d3+d)
sigma2_comp = sigma2_comp + (ur-ul)**2
ul        = (d6*uold(ind_nbor(1,6),4) + d*uold(ind_cell(i),4))/(d6+d)
ur        = (d5*uold(ind_nbor(1,5),4) + d*uold(ind_cell(i),4))/(d5+d)
sigma2_comp = sigma2_comp + (ur-ul)**2

!!!!!!!!!!!!
! Curl terms
!!!!!!!!!!!!
ul        = (d6*uold(ind_nbor(1,6),3) + d*uold(ind_cell(i),3))/(d6+d)
ur        = (d5*uold(ind_nbor(1,5),3) + d*uold(ind_cell(i),3))/(d5+d)
sigma2_sole = sigma2_sole + (ur-ul)**2
ul        = (d4*uold(ind_nbor(1,4),4) + d*uold(ind_cell(i),4))/(d4+d)
ur        = (d3*uold(ind_nbor(1,3),4) + d*uold(ind_cell(i),4))/(d3+d)
sigma2_sole = sigma2_sole + (ur-ul)**2
ul        = (d6*uold(ind_nbor(1,6),2) + d*uold(ind_cell(i),2))/(d6+d)
ur        = (d5*uold(ind_nbor(1,5),2) + d*uold(ind_cell(i),2))/(d5+d)
sigma2_sole = sigma2_sole + (ur-ul)**2
ul        = (d2*uold(ind_nbor(1,2),4) + d*uold(ind_cell(i),4))/(d2+d)
ur        = (d1*uold(ind_nbor(1,1),4) + d*uold(ind_cell(i),4))/(d1+d)
sigma2_sole = sigma2_sole + (ur-ul)**2
ul        = (d4*uold(ind_nbor(1,4),2) + d*uold(ind_cell(i),2))/(d4+d)
ur        = (d3*uold(ind_nbor(1,3),2) + d*uold(ind_cell(i),2))/(d3+d)
sigma2_sole = sigma2_sole + (ur-ul)**2
ul        = (d2*uold(ind_nbor(1,2),3) + d*uold(ind_cell(i),3))/(d2+d)
ur        = (d1*uold(ind_nbor(1,1),3) + d*uold(ind_cell(i),3))/(d1+d)
sigma2_sole = sigma2_sole + (ur-ul)**2
sigma2    = sigma2_comp+sigma2_sole

! Trace of gradient velocity tensor
trgv      = sigma2/dx_loc**2
##################################################




##################################################
When(d>d0)


!  Federrath+ (2012) best fit model, see Kimm+ (2017) but with no jeans criterion, equivalent to NH
CASE (6)
   alpha0    = (5.0*sigma2)/(pi*factG*d*dx_loc**2)
   b_turb    = 0.4
   phi_t     = 0.57
   theta     = 0.33
   sigs      = log(1.0+(b_turb**2)*(sigma2/cs2))
   scrit     = log(0.067/(theta**2)*alpha0*(sigma2/cs2))

   sfr_ff(i) = eps_star/2.0*phi_t*exp(3.0/8.0*sigs)*(2.0-erfc_pre_f08((sigs-scrit)/sqrt(2.0*sigs)))
END SELECT
##################################################


##################################################
&REFINE_PARAMS
ivar_refine=16
var_cut_refine=0.01
##################################################
! Geometrical criterion
if(ivar_refine>0)then
   do i=1,ngrid
      d=uold(ind_cell(i),ivar_refine)
      if(d<=var_cut_refine) ok(i)=.false.
   end do
endif
##################################################


##################################################
! Calculate number of new stars in each cell using Poisson statistics
do i=1,ngrid
nstar(i)=0
if(ok(i))then
    ! Compute mean number of events
    d=uold(ind_cell(i),1)
    mcell=d*vol_loc
    ! Free fall time of an homogeneous sphere
    tstar= .5427*sqrt(1.0/(factG*max(d,smallr)))
    ! Gas mass to be converted into stars
    mgas=dtnew(ilevel)*(sfr_ff(i)/tstar)*mcell
    ! Poisson mean
    PoissMean=mgas/mstar
    if((trel>0.).and.(.not.cosmo)) PoissMean = PoissMean*min((t/trel),1._dp)
    ! Compute Poisson realisation
    call poissdev(seed,PoissMean,nstar(i))
    ! Compute depleted gas mass
    mgas=nstar(i)*mstar
    ! Security to prevent more than 90% of gas depletion
    if (mgas > 0.9*mcell) then
        nstar_corrected=int(0.9*mcell/mstar)
        mstar_lost_tmp=mstar_lost_tmp+(nstar(i)-nstar_corrected)*mstar
        nstar(i)=nstar_corrected
    endif
    ! Compute new stars local statistics
    mstar_tot_tmp=mstar_tot_tmp+nstar(i)*mstar
    if(nstar(i)>0)then
        ntot=ntot+1
        !if(f_w>0 .and. mechanical_feedback==0)ndebris_tot=ndebris_tot+1
    endif
endif
enddo
##################################################





function erfc_pre_f08(x)

! complementary error function
  use amr_commons, ONLY: dp
  implicit none
  real(dp) erfc_pre_f08
  real(dp) x, y
  real(kind=8) pv, ph
  real(kind=8) q0, q1, q2, q3, q4, q5, q6, q7
  real(kind=8) p0, p1, p2, p3, p4, p5, p6, p7
  parameter(pv= 1.26974899965115684d+01, ph= 6.10399733098688199d+00)
  parameter(p0= 2.96316885199227378d-01, p1= 1.81581125134637070d-01)
  parameter(p2= 6.81866451424939493d-02, p3= 1.56907543161966709d-02)
  parameter(p4= 2.21290116681517573d-03, p5= 1.91395813098742864d-04)
  parameter(p6= 9.71013284010551623d-06, p7= 1.66642447174307753d-07)
  parameter(q0= 6.12158644495538758d-02, q1= 5.50942780056002085d-01)
  parameter(q2= 1.53039662058770397d+00, q3= 2.99957952311300634d+00)
  parameter(q4= 4.95867777128246701d+00, q5= 7.41471251099335407d+00)
  parameter(q6= 1.04765104356545238d+01, q7= 1.48455557345597957d+01)

  y = x*x
  y = EXP(-y)*x*(p7/(y+q7)+p6/(y+q6) + p5/(y+q5)+p4/(y+q4)+p3/(y+q3) &
       &       + p2/(y+q2)+p1/(y+q1)+p0/(y+q0))
  if (x < ph) y = y+2d0/(exp(pv*x)+1.0)
  erfc_pre_f08 = y

  return

end function erfc_pre_f08